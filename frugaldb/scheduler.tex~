\section{Migration Scheduler}\label{sec:PFA}

\subsection{Problem Formulation}
Here we formally present definitions to notations about tenants and database servers as follows. The set of all tenants is denoted as $TS$, and each tenant $T_i \in TS$ is described as a quadruple $\{SLO_i, WC_i, DS_i, WL_{i, t}\}$, where $SLO_i$ denotes $T_i$'s performance SLO (namely the maximum workload that may be generated by $T_i$), $WC_i$ denotes $T_i$'s workload characteristics, $DS_i$ denotes $T_i$'s data size and $WL_{i, t}$ denotes $T_i$'s workload at time $t$. For simplicity, we quantify tenants' SLOs by three levels: High Level, Middle Level and Low Level, and we take the percentage of write requests over total requests as the only workload characteristic metric, which identifies a tenant's workload as Write-Heavy~(WH) or Read-Heavy~(RH), forming the two possible values of $WC_i$. Furthermore, all active tenants at time $t$ are denoted as active tenants $T_{a, t}$. We consider the size of $T_{a, t}$ as a constant proportion over the size of all tenants. We denote the average percentage of write requests over all requests submitted to the data serving engine at time $t$ as $\overline{WP_t}$. We denote the maximum request processing capacity of both disk-based database and in-memory database at time $t$ as $WL_{M, t}$ and $WL_{V, t}$ respectively, and deem them as functions of $\overline{WP_t}$, where $WL_{M, t} = F(\overline{WP_t})$ and $WL_{V, t} = G(\overline{WP_t})$. $M_V$ denotes the maximum size of memory configured for data storage in the in-memory database. Finally, we define \emph{workload bursts} as circumstances when the overall workload submitted to the data serving engine exceeds the maximum request processing capacity of the disk-based database.

We then formalize the crux of our solution as an optimization problem. When a workload burst occurs to the data serving engine at time $t$, our goal is to assign each active tenant to one of the three tenant sets: $T_{M, t}$, $T_{Vo, t}$ and $T_{Vi, t}$, so as to minimize violations of QoS guarantees for meeting tenants' performance SLOs, where performance SLOs of tenants in $T_{M, t}$ will be met by requesting data from the disk-based database, performance SLOs of tenants in $T_{Vo, t}$ will be met by requesting data from the in-memory database, and performance SLOs of tenants in $T_{Vi, t}$ will be omitted and these tenants' data serving requests should be rejected, as the data serving engine does not possess enough capacity to meet all tenants' performance SLOs at time $t$. So our optimization goal is to minimize:
\begin{equation}\label{objectivefunction}
 |T_{Vi ,t}|,
\end{equation}
subject to:
\begin{equation}\label{constraint1}
T_{M, t} \cup T_{Vo, t} \cup T_{Vi, t} = T_{a, t}
\end{equation}
\begin{equation}\label{constraint2}
T_{M, t} \cap T_{Vo, t} = \emptyset, T_{M, t} \cap T_{Vi, t} = \emptyset, T_{Vo, t} \cap T_{Vi, t} = \emptyset
\end{equation}
\begin{equation}\label{constraint3}
\sum_{m \in T_{M, t}}{WL_{m, t}} \leq B_M * WL_{M, t}
\end{equation}
\begin{equation}\label{constraint4}
\sum_{v \in T_{Vo, t}}{DS_v} \leq M_V
\end{equation}
\begin{equation}\label{constraint5}
\sum_{v \in T_{Vo, t}}{C_v * DS_v} + \sum_{v \in T_{Vo, t}}{WL_{v, t}} \leq WL_{V, t}.
\end{equation}

The first two constraints guarantee that each active tenant is exactly assigned to one tenant set of $T_{M, t}$, $T_{Vo, t}$ and $T_{Vi, t}$. The third constraint guarantees that the overall workloads of active tenants assigned to the disk-based database does not exceed its maximum request processing capacity. The fourth constraint guarantees that the overall data size of active tenants assigned to the in-memory database does not exceed its memory size. The fifth constraint guarantees that the combined workload pressure resulted from workload offloading plus normal data serving requests submitted by tenants assigned to the in-memory database does not exceed its maximum request processing capacity.

\subsection{Optimization Algorithms}\label{sec:Optimization-Algorithms}

Finally, we present the algorithms proposed to solve our targeting optimization problem. We first introduce algorithms employed to optimize our targeting scenario where tenants' workloads are generated according to the deterministic model, while another targeting scenario where tenants' workloads are generated according to the non-deterministic model could be optimized in similar fashion, only that we employ the expectations of corresponding probability parameters which are used to describe each tenant's workload.

Before a workload burst occurs, all tenants's data serving requests are handled in the disk-based database. As it takes time to generate and finish executing a workload offloading plan, FrugualDB needs to look ahead at future time ranges to judge whether a workload burst is about to occur, so that those highly active tenant's high-intensity workloads could be dealt with by the in-memory database, and the huge workload processing pressure yielded by these high-intensity workloads could be really relieved from disk-based database, and it could focus on processing those low-intensity workloads. If FrugalDB otherwise does not begin to migrate data of high-intensity workloads into the in-memory database ahead of time, it may not be able to successfully offload these high-intensity workloads from the disk-based database in time, as these workloads may have fallen from high-intensity to low-intensity when FrugalDB finishes data migration.

We subsequently assume that a tenant's workload in time $t$ is predictable, and FrugalDB can start the workload offloading ahead of time $t$ at time $t'$, which means $t'$ \textless $t$,
so we can ignore the first part in Constraint.~\ref{constraint5}, and get a new constraint:
\begin{equation}\label{constraint8}
    \sum_{v \in T_{Vo, t}}{WL_{v, t}} \leq WL_{V, t}.
\end{equation}
However, this constraint can also be ignored because of the high performance of the in-memory database, where we deem the in-memory database' bottleneck is its memory capacity, rather than its query processing capacity. Thus we finally totally remove Constraint.~\ref{constraint5} and just consider Constraint.~\ref{constraint1}, Constraint.~\ref{constraint2}, Constraint.~\ref{constraint3}, Constraint.~\ref{constraint4}. Note that the total workload at time $t$ is fixed, and we denote it as:
\begin{equation}\label{constraint10}
    WLT_t=\sum_{m \in T_{M, t}}{WL_{m, t}} +\sum_{v \in T_{Vo, t}}{WL_{v, t}}+\sum_{u \in T_{Vi, t}}{WL_{u, t}}.
\end{equation}

So our main goal is to maximize the second part of Equation.~\ref{constraint10} subjected to constraints other than Constraint.~\ref{constraint5}. If this goal is achieved, we can conclude that the value:
\begin{equation}\label{constraint11}
    \sum_{m \in T_{M, t}}{WL_{m, t}} +\sum_{u \in T_{Vi, t}}{WL_{u, t}}=\sum_{x \notin T_{Vo,t}}{WL_{x,t}}
\end{equation}
is minimized. If this value satisfy the following condition:
\begin{equation}\label{constraint12}
    \sum_{x \notin T_{Vo, t}}{WL_{x, t}} \leq B_M * WL_{M, t},
\end{equation}
we can just assign all the tenants who is in the set $T_{a,t}$ but not in set $T_{Vo,t}$ to set $T_{M,t}$, and get the best expected result: $|T_{Vi,t}|=0$.

However, we may not be able to satisfy Condition.~\ref{constraint12} often than not, therefore we must decide which tenants should be assigned to set $T_{Vi,t}$ subjected to Constraint.~\ref{constraint3}, so that the object function could be minimized. For this problem, we can just sort the tenants according to their workload from high to low, and assign tenants from top to bottom to set $T_{Vi,t}$ until Constraint.~\ref{constraint3} is to be violated. Then the remaining and most important part is how to maximize the second part of the Equation.~\ref{constraint10} subjected to the Constraint.~\ref{constraint4}. This problem is a classical 0/1 knapsack problem, and we can adopt a dynamic programming solution to solve the 0/1 knapsack problem. We could define a function $F(i,m)$ as the maximum of second part of the Equation.~\ref{constraint10}, when we consider the first $i$ tenants in the set $T_{a,t}$, subjected to the following constraint:
\begin{equation}\label{constraint13}
    \sum_{v \in T_{Vo, t}}{DS_{v}}\leq m.
\end{equation}
Note that Constraint.~\ref{constraint13} is different from Constraint.~\ref{constraint4}, where $M_v$ is replaced by the value $m$. So $F(n,M_v)$ is the optimization value we need to compute.
It is obvious that:
\begin{equation}\label{constraint14}
    F(0,m)=0,0\leq m\leq M_v.
\end{equation}
For $i>0$, we have:
\begin{equation}
 F(i,m)=\left\{
 \begin{array}{lr}
 min(F(i-1,m),F(i-1,m-DS_{i})+WL_{i,t}), &   \\
 \qquad \qquad \qquad \qquad \qquad \qquad \quad DS_{i}\leq m\leq M_v &  \\
 F(i-1,m), 0\leq m< DS_{i} \\
 \end{array}\right\}
 \end{equation}

We also define a function $P(i,m)$ as:
 \begin{equation}
 P(i,m)=\left\{
 \begin{array}{lr}
 -1,&i=0\\
 0,&(i>0) \land (m<DS_i \lor F(i,m)\ne \\
 &F(i-1,m-DS_i)+WL_{i,t})\\
 1,&i>0 \land m \ge DS_i \land F(i,m)=\\
  &F(i-1,m-DS_i)+WL_{i,t}
 \end{array}\right\}
 \end{equation}

We use function $P$ to find out which tenants should be assign to set $T_{Vo,t}$, and Alg.~\ref{alg:1} and Alg.~\ref{alg:2} describe tenant assignment process and the overall algorithm for solving 0/1 knapsack problem respectively. In Alg.~\ref{alg:1}, L1 and L2 initialize two sets of tenants $T_{M,t}$ and $T_{Vi,t}$, L3 calls Alg.~\ref{alg:2} to compute the value F(n,$M_v$) and the set $T_{Vo,t}$, L4 to L10 put all the tenants in set $T_{M,t}$ except those who are already in set $T_{Vo,t}$, and calculate the total workload produced by these tenants. L11 to L16 decide which tenants will finally be assigned to set $T_{Vi,t}$. In Alg.~\ref{alg:2}, L1 to L5 initialize the set of tenants who will be moved to in-memory database, the function F and the function P, L6 to L20 solve the 0/1 knapsack program through dynamic programming, L21 to L29 compute the set of tenants who are going to be moved to the in-memory database.

\begin{algorithm}[!htb]
\caption{Tenant assignment}
\label{alg:1}
    \begin{algorithmic}[1]
    \Require $t$, $T_{a, t}$,$M_v$,$WL_{M,t}$
     \State $T_{M, t} \gets \{\}$
      \State $T_{Vi, t} \gets \{\}$
      \State Run Algorithm 2 to get $F(n,M_v)$ and $T_{Vo,t}$
      \State $WLT_t\gets 0$
      \For{$i=1$ to $n$}
      \If{i is not in set $T_{Vo,t}$}
      \State $WLT_t\gets WLT_t+WL_{i,t}$
      \State $T_{M,t}\gets T_{M,t}+\{i\}$
      \EndIf
      \EndFor
      \While{$WLT_t>WL_{M,t}$}
      \State $id\gets $top($T_{M,t}$)
      \State $WLT_t\gets WLT_t-WL_{id,t}$
      \State $T_{Vi,t}\gets T_{Vi,t}+\{id\}$
      \State $T_{M,t}\gets T_{M,t}-\{id\}$
      \EndWhile
      \Ensure $T_{M,t},T_{Vo,t},T_{Vi,t}$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htb]
\caption{Maximize workload in the in-memory database}
\label{alg:2}
    \begin{algorithmic}[1]
    \Require $t$, $T_{a, t}$,$M_v$
    \State $T_{Vo, t} \gets \{\}$
    \For{$m=0$ to $M_v$ }
    \State $F(0,m) \gets 0$
    \State $P(0,m) \gets -1$
    \EndFor
    \For{$i=1$ to $n$}
       \For{$m=0$ to $M_v$}
           \If{$m\ge DS_i$}
           \State $F(i,m)\gets min(F(i-1,m),F(i-1,m-DS_i)+WL_{i,t})$
                  \If{$F(i,m)=F(i-1,m-DS_i)+WL_{i,t}$}
                  \State $P(i,m)\gets 1$
                  \Else
                  \State $P(i,m)\gets 0$
                  \EndIf
          \Else
          \State $F(i,m)\gets F(i-1,m)$
          \State $P(i,m)\gets 0$
          \EndIf
        \EndFor
      \EndFor
     \State $id\gets n$
     \State $capacity\gets M_v$
     \While{$id\ne 0$}
     \If{$P(id,capacity)=1$}
     \State $T_{Vo,t}\gets T_{Vo,t}+\{id\}$
     \State $capacity\gets capacity-DS_id$
     \EndIf
     \State $id\gets id-1$
     \EndWhile
     \Ensure $F(n,M_v),T_{Vo,t}$
    \end{algorithmic}
\end{algorithm}